module Options where

import Din.Types (LogLevel(..),Env(..))
import Storage.Db (withStorage)

import System.Console.GetOpt
    (ArgOrder(..),OptDescr(..),ArgDescr(..),usageInfo,getOpt)
import System.Directory
    (getHomeDirectory,doesDirectoryExist,createDirectoryIfMissing)
import System.Environment (getProgName)
import System.Exit (exitFailure,exitSuccess)
import System.FilePath ((</>),takeDirectory)


-- Options ---------------------------------------------------------------------

-- | Command-line options.
data Options = Options
  { optLogLevel   :: LogLevel
  , optDbLocation :: FilePath
  } deriving (Show)

-- | Default @Options@.
defaultOptions :: IO Options
defaultOptions  = do
  home <- getHomeDirectory
  return Options
    { optLogLevel   = LogError
    , optDbLocation = home </> ".din" </> "library.db"
    }

-- | Run a continuation with the environment generated by an @Options@.
withOptionsEnv :: Options -> (Env -> IO a) -> IO a
withOptionsEnv opts k = do
  fresh <- ensureDbPath (optDbLocation opts)
  withStorage (optDbLocation opts) $ \ h -> k Env
    { envDbHandle = h
    , envLogLevel = optLogLevel opts
    , envDbFresh  = fresh
    }

-- | Make sure that the directory that a database will reside in exists already.
ensureDbPath :: FilePath -> IO Bool
ensureDbPath path
  | path == ":memory:" = return True
  | otherwise          = do
    let dir = takeDirectory path
    exist <- doesDirectoryExist dir
    createDirectoryIfMissing True dir
    return (not exist)


-- Options Parsing -------------------------------------------------------------

-- | Parsers for individual flags.
type Parse = IO (Options -> Options)

options :: [OptDescr Parse]
options  =
  [ Option "h" ["help"] (NoArg displayHelp)
    "Display this message"

  , Option "d" ["database"] (ReqArg setDbLocation "PATH")
    "Location of the song database"

  , Option "v" ["log-level"] (ReqArg parseLogLevel "INT")
    "Log level for console output"
  ]

-- | Handler for the -h switch.
displayHelp :: Parse
displayHelp  = do
  displayUsage []
  exitSuccess

-- | Setters for required option arguments.
type Required = String -> Parse

-- | Set the optDbLocation field of an @Options@.
setDbLocation :: Required
setDbLocation str = return (\opts -> opts { optDbLocation = str })

-- | Parse out the optLogLevel field of an @Options@ record.
parseLogLevel :: Required
parseLogLevel str = case reads str of
  [(n,[])] -> setLogLevel n
  _        -> fail ("Invalid log level: " ++ str)

-- | Set the log level in an @Options@ structure.
setLogLevel :: Int -> Parse
setLogLevel n
  | validLogLevel n = return (\opts -> opts { optLogLevel = toEnum n })
  | otherwise       = fail "Invalid log level, must be in the range [0,3]"

-- | Deterimine if an integer representation of a @LogLevel@ is valid.
validLogLevel :: Int -> Bool
validLogLevel n = n >= fromEnum LogError && n <= fromEnum LogDebug

-- | Parse an @Options@ from a set of input arguments.
parseOptions :: [String] -> IO Options
parseOptions args = do
  case getOpt Permute options args of

    (fs,_,[])  -> do
      setters  <- sequence fs
      foldl (.) id setters `fmap` defaultOptions

    (_,_,errs) -> do
      displayUsage errs
      exitFailure

-- | Display the usage string for the options.
displayUsage :: [String] -> IO ()
displayUsage errs = do
  prog <- getProgName
  let banner = unlines (errs ++ ["usage: " ++ prog ++ " [OPTIONS]"])
  putStrLn (usageInfo banner options)
